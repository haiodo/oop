# ФИТ НГУ, курс ООП. Задача 1 (раздельная компиляция и Word Count)

Цель: познакомиться с инструментами разработки C++ (Git, CMake, тесты), раздельной компиляцией и пространствами имен; решить задачу по обработке текста.

## Порядок действий

0. Пройти краткий курс по Git: https://learngitbranching.js.org (базовые вещи).
1. Зарегистрироваться на GitHub и создать приватный репозиторий. Предоставить доступ преподавателю для проверки.
2. Склонировать шаблонный репозиторий: https://github.com/haiodo/oop (используйте как основу).
3. Начать выполнение заданий.

## Требования к оформлению

1. Для каждой подзадачи используйте отдельную папку и отдельную ветку (например, task-1a, task-1b). Для проверки создайте Pull Request и добавьте преподавателя в ревьюеры.
2. Решение задачи 1b должно содержать тесты на GoogleTest (минимум 2 теста). Для 1a тесты по желанию.
3. Проекты должны собираться через CMake (кроссплатформенно).
4. Рекомендуется настроить GitHub Actions для автоматической сборки и запуска тестов.

---

## Задача 1a. Раздельная компиляция и пространства имен

Познакомьтесь с раздельной компиляцией и пространствами имен в C++ на примере:

Файл module1.h:

```c++
#include <string>

namespace Module1 {
  std::string getMyName();
}
```

Файл module1.cpp:

```c++
#include "module1.h"

namespace Module1 {
  std::string getMyName() {
    std::string name = "John";
    return name;
  }
}
```

Файл module2.h:

```c++
#include <string>

namespace Module2 {
  std::string getMyName();
}
```

Файл module2.cpp:

```c++
#include "module2.h"

namespace Module2 {
  std::string getMyName() {
    std::string name = "James";
    return name;
  }
}
```

Файл main.cpp:

```c++
#include "module1.h"
#include "module2.h"
#include <iostream>

int main(int argc, char** argv)
{
  std::cout << "Hello world!" << "\n";

  std::cout << Module1::getMyName() << "\n";
  std::cout << Module2::getMyName() << "\n";

  using namespace Module1;
  std::cout << getMyName() << "\n"; // (A)
  std::cout << Module2::getMyName() << "\n";

  //using namespace Module2; // (B)
  //std::cout << getMyName() << "\n"; // COMPILATION ERROR (C)

  using Module2::getMyName;
  std::cout << getMyName() << "\n"; // (D)
}
```

Что нужно сделать:

1. Собрать программу и убедиться, что на каждый .cpp создается отдельный объектный файл:
   - g++/Clang: .o
   - MSVC: .obj (например, в директории Debug)
2. Изменить один .cpp и пересобрать: должен обновиться только соответствующий ему объектный файл (у остальных дата изменения прежняя).
3. Объяснить, что выведется в местах (A) и (D) в main.cpp.
4. Раскомментировать строки (B) и (C) и убедиться, что возникает ошибка компиляции. Объяснить причину и предложить варианты исправления.
5. Добавить еще одну функцию getMyName(), возвращающую "Peter", в новом пространстве имен (например, Module3), и вывести результат в main.cpp.
6. Объяснить, как писать cout без std:: (и почему лучше избегать using namespace std; на уровне глобальной области видимости).

Подсказки и ожидаемое поведение:

- (A): после using namespace Module1; вызов getMyName() не квалифицирован и разрешается в пользу Module1::getMyName → вывод "John".
- (B)+(C): если раскомментировать using namespace Module2;, то не квалифицированный getMyName() станет неоднозначным между Module1 и Module2 → ошибка компиляции (ambiguity).
  Варианты исправления: вызывать явно Module1::getMyName()/Module2::getMyName(); убрать один из using namespace; либо использовать точечные using-директивы (например, using Module2::getMyName;) и понимать приоритет имен.
- (D): using Module2::getMyName; вводит именно эту функцию в текущую область видимости, поэтому не квалифицированный вызов выбирает Module2::getMyName → вывод "James".
- Добавление Module3:
  - Создайте module3.h/module3.cpp с функцией, возвращающей "Peter", и выведите Module3::getMyName() в main.cpp.
- Про cout:
  - Можно написать внутри функции main: using std::cout; и использовать cout.
  - Не рекомендуется писать using namespace std; на уровне заголовков/глобально — это увеличивает риск конфликтов имен.

---

## Задача 1b. Подсчет частот слов и вывод CSV

Написать программу, которая принимает имя входного текстового файла и имя выходного CSV-файла, и записывает в CSV три колонки:

1. слово, 2) частота, 3) частота в %.

Командная строка:

```bash
word_count.exe input.txt output.csv
```

Требования:

- Разделителями считать все символы, кроме букв и цифр (т.е. слово — подряд идущие [A-Za-z0-9] и буквы национальных алфавитов; упрощенно можно считать isalnum).
- Регистр можно унифицировать: приведите к нижнему (lowercase), чтобы "Word" и "word" считались одним словом.
- CSV упорядочить по убыванию частоты (самые частые в начале). При равной частоте порядок не принципиален.
- Работа со строками — std::string.
- Работа с файлами — std::ifstream/std::ofstream из <fstream>.
- Чтение строк — std::getline.
- Данные:
  - Можно сохранять прочитанные строки в std::list<std::string>.
  - Частоты хранить в std::map<std::string, std::size_t> (или std::unordered_map).
- Подсчет процентов: percent = 100.0 \* count / total_words. Формат с разумной точностью (например, 2–3 знака после запятой).
- Формат CSV: заголовок и затем строки вида:
  ```
  word,count,percent
  the,123,12.30
  ...
  ```

Подсказки:

- Парсинг: заменяйте неалфанумерические символы на пробелы и затем разбивайте по пробелам.
- Сортировка для вывода: соберите пары (слово, частота) в вектор и отсортируйте по частоте по убыванию.
- Обработка ошибок: проверьте, что входной файл открылся; при ошибке — сообщите в stderr и верните ненулевой код.

---

## Сборка и CI (кратко)

- CMake: добавьте CMakeLists.txt, цель(и) для 1a и 1b, и (для 1b) цель с GoogleTest.
- Пример сборки: `cmake -S . -B build && cmake --build build`
- GitHub Actions: настроить job, который собирает проект и запускает тесты (по желанию, но рекомендуется).
