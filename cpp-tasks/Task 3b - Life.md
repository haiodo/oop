# ФИТ НГУ, курс ООП

## Задача 3b. Игра “Жизнь”

### Общие сведения

Игра «Жизнь» - клеточный автомат, подробно описанный по [ссылке](http://en.wikipedia.org/wiki/Conway's_Game_of_Life)

#### Описание клеточного автомата

- Поле: прямоугольная решетка W×H, каждая ячейка в одном из двух состояния: «живая» или «мёртвая».
- Соседство: 8 соседей (соседство Мура).
- Граница: поле тороидально замкнуто по горизонтали и вертикали (координаты индексируются по модулю W и H).
- Правило: Life-like (нотация Bx/Sy). Рождение (B) — мёртвая клетка становится живой, если число живых соседей ∈ x. Выживание (S) — живая клетка остаётся живой, если число живых соседей ∈ y. Иначе — умирает/остаётся мёртвой.
- Обновление: синхронное. Следующее состояние всех клеток рассчитывается исходя только из текущего состояния, затем применяется одновременно.
- Семантика тика: один tick — один шаг применения правила ко всему полю. Счетчик итераций увеличивается на 1 за каждый совершенный шаг.

#### Требования к программе

Уметь считывать «вселенную» из файла (см. формат файла ниже). Вселенная описывается (а) правилом перехода клетки; (б) размером поля; (в) состоянием ячеек. Файл может подаваться программе при старте в качестве параметра входной строки.

В случае, если файл не подан, начинать игру на произвольно инициализированном поле некоего фиксированного размера, красиво отображающегося на консоли. Поле, инициализированное случайным образом малоинтересно, поэтому рекомендуется начинать игру на каких-нибудь заранее продуманных примерах.

Третий режим ("оффлайн"): программе подается входной файл, количество итераций, выходной файл. Программа рассчитывает состояние поля после указанного количества итераций и сохраняет вселенную в указанный выходной файл. Параметры командной строки: -i x либо --iterations=x - количество итераций, -o filename либо --output=filename - выходной файл.

После старта игры, программа ожидает команды:
`dump <filename>` - сохранить вселенную в файл
`tick <n=1>` (и сокращенно t <n=1>) - рассчитать n (по умолчанию 1) итераций и напечатать результат. На экране перед распечатанным полем должно отображаться имя вселенной, правило перехода и номер текущей итерации.
`exit` – завершить игру
`help` – распечатать справку о командах

Должен поддерживаться расчет по разным правилам перехода состояний ячеек (см. формат файла).

Поле игры считать замкнутым (тороидальным). Таким образом, соседи сверху первого ряда поля - клетки последнего ряда и наоборот, аналогично для левого и правого краев вселенной.

Программа должна быть разбита на классы, использование единственного God Object, хранящего состояние игры, рассчитывающего состояния и взаимодействующего с пользователем, не допускается.

Реализация программы подразумевает активное освоение стандартной библиотеки: файловых потоков, контейнеров, алгоритмов.

Реализация игры подразумевает «играбельность» и максимальную дружелюбность к пользователю: ясные сообщения об ошибках формата файла, и пр., наличие справки и демонстрация ее при неправильном вводе и т. д.

Основной функционал ("механика") игры должен быть покрыт юнит-тестами.

При сдаче задания продемонстрировать 5-10 примеров интересных вселенных с различными правилами перехода (можно брать с википедии или профильных ресурсов).

### Требования к реализации автомата

Требования касаются внутренней «механики» и API модуля клеточного автомата.

- Архитектура:
  - Разделить модель автомата, ввод/вывод и интерфейс пользователя. Никакого «God Object».
  - Рекомендуемые сущности:
    - Rule: хранит множества birth/survival, парсит строку "Bx/Sy", форматирует обратно.
    - Universe (или Grid): хранит размеры, имя, правило, номер итерации и состояние клеток; реализует шаг(и) эволюции.
- Интерфейсы (примерно):
  - Rule:
    - static Rule parse(string), string toString()
    - bool allowsBirth(int n), bool allowsSurvival(int n)
  - Universe:
    - size(): {width,height}, iteration(): uint64_t
    - bool get(int x,int y) const, void set(int x,int y,bool alive)
    - void tick(size_t n=1) — выполняет n синхронных шагов
    - int countAliveNeighbors(int x,int y) const
- Инварианты и семантика:
  - Счетчик итераций увеличивается строго на число выполненных шагов.
  - Обновление — строго синхронное: запрещено «на месте» без двойного буфера или эквивалентной техники.
  - Обращение к координатам — тороидальное: x=(x%W+W)%W, y=(y%H+H)%H.
  - Детерминизм: при одинаковом входе результат идентичен.
- Сложность и производительность:
  - Временная: O(W·H) на один tick при плотном представлении.
  - Память: O(W·H). Допускается двойной буфер или битовые представления.
  - Поле до 1000×1000 должно обрабатываться «интерактивно» (десятки миллисекунд–сотни мс на tick в релизной сборке) — ориентир, не жёсткий критерий.
- Представление данных:
  - Допустимы vector<uint8_t>/bitset/битовые массивы. Разреженное представление — опционально.
- Ввод/вывод и формат:
  - Разбор Life 1.06 с поддержкой #N (имя) и #R (правило); при отсутствии — предупреждение и значения по умолчанию.
  - Повторяющиеся координаты и некорректные строки — предупреждения, некритичное — не прерывает работу.
- Ошибки и сообщения:
  - Ясные сообщения об ошибках формата. Некритичное — warning в stderr; критичное — ошибка и ненулевой код возврата (в оффлайн-режиме).
- Тестируемость:
  - Логика Rule и Universe покрыта юнит-тестами, без необходимости файлового ввода/вывода для базовой механики.

### Примеры обязательных тестов автомата

- Парсинг правил:
  - "B3/S23" → корректные множества; форматирование обратно.
  - Пустые/повторяющиеся цифры, вне диапазона [0..8] → предупреждения/ошибки по месту.
- Подсчет соседей с учетом тороидальности:
  - Углы/границы дают корректные значения через «оборачивание».
- Применение правил:
  - Классика B3/S23:
    - Block (стабильный), Beehive (стабильный) — не меняются.
    - Blinker (период 2), Toad (период 2) — корректная осцилляция.
    - Glider — двигается и корректно «оборачивается» за границей.
- Мульти-тик:
  - tick(n) эквивалентен последовательному вызову tick() n раз и корректно увеличивает счетчик.
- Ввод/вывод:
  - Загрузка → немедленный dump сохраняет эквивалентный файл (с точностью до порядка несущественных строк).
  - Отсутствие #N/#R — предупреждение, используются значения по умолчанию.

### Формат файла

Life 1.06 (http://conwaylife.com/wiki/Life_1.06)

#### Дополнение к формату

Вторая строка файла содержит комментарий с именем вселенной (произвольная строка)

Пример:

`#N My universe`

Третья строка файла должна содержать комментарий с правилом перехода следующего вида:

`#R Bx/Sy` - где `x` и `y` - последовательности различных цифр из множества {0...8}.

Последовательность под буквой `B (birth)` содержит количества живых ячеек, необходимых для "рождения" клетки, под буквой `S (survival)` - ячеек, необходимых для "выживания" клетки (см. MCell notation по ссылке http://en.wikipedia.org/wiki/Life-like_cellular_automaton).

Пример:
`#R B3/S23` - классическая игра жизнь (3 ячейки для рождения, 2 или 3 – для выживания)
`#R B3/S01234567` - ячейки бессмертны.

При разборе формата о некритических ошибках сообщать предупреждениями и продолжать работу (например, повторяющиеся координаты живой ячейки, отсутствие имени или правила перехода)

#### Ссылки

- http://en.wikipedia.org/wiki/Conway's_Game_of_Life
- http://conwaylife.com/wiki/Life_1.06
- http://conwaylife.com/
- http://golly.sourceforge.net/

### Технические требования

1. Проект должен собираться с помощью CMake. Шаблон проекта для CMake с описанием, как все настроить, см. в папке [cpp-template](../cpp-template).
2. Должны быть тесты с использованием GoogleTest. В шаблоне для CMake GoogleTest уже подключен, вам лишь нужно их написать.
3. Покрыть юнит-тестами Rule и Universe (см. «Примеры обязательных тестов автомата»).
4. В оффлайн-режиме при успешной работе возвращать код 0; ошибки формата — ненулевой код и сообщение в stderr.

### Усложненное условие для получения «автомата»

Чтобы претендовать на «автомат» по курсу, необходимо до дедлайна выполнить все обязательные пункты и не менее 3 опциональных, а также предоставить воспроизводимую демонстрацию.

- Обязательные (все):

  - Покрытие юнит‑тестами механики ≥ 85% по основному коду (Rule/Universe, включая негативные кейсы парсинга). Все тесты зелёные в Debug и Release.
  - Полная поддержка Life 1.06: корректный import/export без потерь (#N, #R, координаты). Dump → Load → Dump идемпотентен.
  - Сборка без предупреждений в Release; успешный прогон AddressSanitizer и UndefinedBehaviorSanitizer (без утечек/UB).

- Опциональные (выберите любые 3):

  - Формат RLE: импорт и экспорт (https://conwaylife.com/wiki/Run_Length_Encoded).
  - Разрежённое «почти бесконечное» поле: хранить только живые клетки; корректная эволюция без фиксированных границ (или опция переключения с тором).
  - Многопоточность tick с разбиением поля; измеримая ускоряемость ≥ 1.5× на 4 логических ядрах (указать конфигурацию).
  - Бит‑упаковка и векторизация: потребление памяти снижено ≥ в 8 раз относительно наивного uint8_t, с сохранением корректности.
  - TUI (ncurses): пауза/продолжить, скорость, перемещение по полю, загрузка/сохранение из интерфейса.
  - Пул пресетов и правил: ≥ 10 интересных вселенных; команды list и load <name>.
  - CI (GitHub Actions): сборка Debug/Release, юнит‑тесты, санитайзеры, clang-tidy без ошибок; публикация артефактов.
  - Документация: Doxygen для публичных API + краткая архитектура и описание форматов (docs/ или README).

- Демонстрация и проверка:

  - Бенчмарк‑цель (например, make bench или target CMake) с отчётом: размеры поля, число тиков, время, апдейтов/сек.
  - Раздел «Автомат» в README/отчёте: что реализовано, как запустить проверку (команды), результаты бенчмарка, скриншоты/гиф (опц.).

- Основания для отказа в «автомате»:
  - Крэши/зависания/гонки/утечки; несоответствие формату ввода/вывода; невоспроизводимость заявленных результатов.
