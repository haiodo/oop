# ФИТ НГУ, курс ООП

## Задача 5. Упрощенный парсер CSV

### Subtask #1 — печать std::tuple

Используя рекурсивные шаблоны реализовать оператор вывода для std::tuple как свободную функцию (в глобальном пространстве имен), объявленную в подключаемом заголовке:

```c++
// формат вывода: (e0, e1, e2, ...)
template <typename Ch, typename Tr, typename... Args>
std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os,
                                       std::tuple<Args...> const& t);
```

Требования:

- Реализовать через рекурсивные шаблоны (или index_sequence — допустимо).
- Не модифицировать namespace std.
- Пример: std::tuple<int, std::string>{42, "foo"} -> вывод: (42, foo)

### Subtask #2 — простой CSV-парсер

#### Формат

- Строки разделяются символом '\n'.
- Колонки разделяются символом ','.
- Ни ',' ни '\n' не встречаются внутри данных (без экранирования).
- Количество колонок в строке должно совпадать с количеством типов.

#### CSVParser

Нужно написать шаблонный класс CSVParser<Ts...>, позволяющий лениво итерироваться по строкам CSV и получать std::tuple<Ts...>.

Минимальный интерфейс:

- Конструктор: CSVParser(std::istream& in, std::size_t skip_rows = 0);
- Итерация: begin()/end() со стандартным InputIterator (см. cppreference: InputIterator).
- Итератор:
  - value_type = std::tuple<Ts...>
  - iterator_category = std::input_iterator_tag
  - Инкремент читает следующую строку по требованию (lazy).

Преобразование типов:

- Для каждого поля применяется operator>> в соответствующий тип T.
- Для std::string поле берётся как есть.
- Несовпадение количества полей или ошибка парсинга -> исключение std::runtime_error с кратким описанием.

Пример:

```c++
int main() {
    std::ifstream file("test.csv");
    CSVParser<int, std::string> parser(file, 0);
    for (auto const& row : parser) {
        std::cout << row << std::endl; // row: std::tuple<int, std::string>
    }
}
```

### Subtask #3 — улучшенный CSV-парсер

Добавить:

1. Экранирование данных (кавычки).
   - По умолчанию quote = '"'.
   - Внутри "…", разделители колонок и пробелы — это данные, а не разделители.
   - Внутри кавычек последовательность "" интерпретируется как один символ ".
   - Переносы строк внутри кавычек по умолчанию не поддерживаются (упрощение).
2. Конфигурацию парсера:
   - Символ разделителя строк: row_delim (по умолчанию '\n').
   - Символ разделителя колонок: col_delim (по умолчанию ',').
   - Символ экранирования: quote (по умолчанию '"'; можно отключить, например, quote = '\0').
   - Конструктор: CSVParser(std::istream& in, std::size_t skip_rows,
     char row_delim, char col_delim, char quote = '"');
3. Улучшенную обработку ошибок:
   - Бросать исключение CSVParseError с полями: line (1-based), column (1-based, символ в строке), message.
   - Ошибки: незакрытая кавычка, неожиданный конец строки, лишние/недостающие колонки, ошибка преобразования типа.

Примеры:

```c++
std::istringstream in("id;name\n1;\"Doe, John\"\n2;\"Alice \"\"The Ace\"\"\"");
CSVParser<int, std::string> p(in, /*skip*/1, /*row*/'\n', /*col*/';', /*quote*/'"');
for (auto const& row : p) std::cout << row << "\n";
```

### Замечания по реализации

- Итератор — однонаправленный (InputIterator). Храните минимум состояния (ссылка на поток, буфер текущей строки, индекс строки).
- Ленивая загрузка: чтение и разбор следующей записи происходит при ++it/первом dereference.
- Конец итерации определяется достижением EOF и отсутствии данных.
- Парсер должен быть noexcept по копированию итераторов и корректно работать при единственном проходе.

### Технические требования

1. Проект собирается с CMake (см. шаблон в папке [cpp-template](../cpp-template)).
2. Тесты на GoogleTest:
   - Печать tuple: пустой, 1 элемент, несколько элементов, строки со спецсимволами.
   - Простой CSV: корректный парсинг, неверное число колонок, ошибка типа.
   - Улучшенный CSV: кавычки, удвоенные кавычки, пользовательские разделители.
   - Проверка координат в CSVParseError (line/column).
