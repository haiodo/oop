# ФИТ НГУ, курс ООП

## Задача: HashMap (версия для 2 курса)

Реализовать ассоциативный массив (hash map) на основе хеш-таблицы с открытой адресацией, квадратичным пробированием и "надгробиями" (tombstones) для корректного удаления. Ключи и значения — строки (`std::string`). Запрещены все контейнеры STL, кроме `std::string`. Массивы хранятся в "сырых" буферах, созданных через `new[]` и освобождаемых через `delete[]`.

Контейнер должен обеспечивать амортизированную константную сложность в среднем случае для операций поиска/доступа/вставки при ограниченном коэффициенте заполнения.

---

## Обязательный интерфейс

```C++
class HashMap {
public:
    using size_type = std::size_t;

    // Конструирование/жизненный цикл
    explicit HashMap(size_type initial_bucket_count = 8, double max_load_factor = 0.7);
    HashMap(const HashMap& other);
    HashMap(HashMap&& other) noexcept;
    ~HashMap();
    HashMap& operator=(const HashMap& other);
    HashMap& operator=(HashMap&& other) noexcept;

    // Емкость/метрики
    size_type size() const noexcept;
    bool empty() const noexcept;
    size_type bucket_count() const noexcept;
    double load_factor() const noexcept;       // size() / bucket_count()
    double max_load_factor() const noexcept;   // порог для ре-хеширования
    void set_max_load_factor(double mlf);      // [0.5; 0.95], иначе throw std::invalid_argument

    // Управление емкостью
    void reserve(size_type n);                 // увеличить buckets так, чтобы ожидаемо влезло n элементов без ре-хеша
    void rehash(size_type new_bucket_count);   // явный ре-хеш с переносом элементов

    // Доступ/поиск/модификация
    std::string& operator[](const std::string& key);                // вставляет пустое значение при отсутствии
    const std::string& operator[](const std::string& key) const;    // не вставляет; при отсутствии возвращает ссылку на статическую пустую строку
    const std::string& at(const std::string& key) const;            // при отсутствии throw std::out_of_range
    bool contains(const std::string& key) const;
    size_type erase(const std::string& key);                        // 0 или 1
    void clear() noexcept;

    // Итераторы (см. детали ниже)
    class iterator;
    class const_iterator;
    iterator begin() noexcept;
    iterator end() noexcept;
    const_iterator begin() const noexcept;
    const_iterator end() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;
    iterator find(const std::string& key) noexcept;
    const_iterator find(const std::string& key) const noexcept;

private:
    // ...детали реализации...
};
```

Пример использования:

```C++
HashMap student;
student["first_name"] = "Ivan";
student["last_name"]  = "Petrov";
student["university"] = "NSU";
// ...
if (student.contains("first_name")) {
    std::cout << "Student: " << student["first_name"] << " " << student["last_name"] << "\n";
}
```

---

## Ограничения и требования реализации

- Разрешено: `std::string`, базовые заголовки (`<new>`, `<cstddef>`, `<cstdint>`, `<stdexcept>`, `<utility>`, `<limits>`, `<type_traits>`), исключения.
- Запрещено: любые контейнеры STL (`std::vector`, `std::list`, `std::map`, `std::unordered_map`, и т.д.), умные указатели, `<optional>`, `<variant>`.
- Память:
  - Таблица — массив ячеек (слотов), выделенный через `new[]`.
  - Каждая ячейка хранит: состояние (Empty/Occupied/Deleted), ключ и значение.
  - Допускается ленивое конструирование `std::string` в слоте (через размещающее new) и явный вызов деструкторов, либо управление через готовые члены, но с соблюдением строгой гарантийности при вставке.
- Разрешается использовать `std::hash<std::string>`, но для стабильности настоятельно рекомендуется собственный 64-битный FNV-1a или splitmix64 поверх байт ключа.
- Разрешается выбрасывать `std::invalid_argument` (на неверный `max_load_factor`) и `std::out_of_range` в `at()`. Других исключений — по мере необходимости.

---

## Алгоритм и инварианты

- Метод коллизий: открытая адресация с квадратичным пробированием.
  - Последовательность проб: i = 0,1,2,...; idx = (h + c1*i + c2*i\*i) mod bucket_count, с константами c1=1, c2=1 (можно иные, но документируйте).
- Удаление: используйте "надгробия" (Deleted). По достижении доли Deleted > 20% — выполнять ре-хеш.
- Коэффициент заполнения: alpha = size() / bucket_count(), где size() — число Occupied (без Deleted).
  - Порог `max_load_factor` по умолчанию 0.7. При превышении — ре-хеш и рост в 2 раза (минимум 8 бакетов).
  - Рекомендуется поддерживать количество бакетов степенью двойки; индекс можно вычислять как `h & (bucket_count - 1)` при хорошем распределении.
- Хеш:
  - Если используете свой FNV-1a: 64-бит, редукция к индексу через mod или маску (для степени 2).
  - Желательно добавлять смешивание: `h ^= h >> 33; h *= 0xff51afd7ed558ccdULL; h ^= h >> 33;` для уменьшения кластеризации.
- Исключения и безопасность:
  - Вставка обеспечивает как минимум базовую гарантию (данные не повреждаются) и по возможности — сильную (на неудаче состояние не меняется).
  - Любая операция не должна течь памятью при выбросе исключения `std::string`/`new`.

---

## Сложность

- В среднем при alpha ≤ max_load_factor:
  - contains/find/operator[]/at: O(1) амортизированно.
  - erase: O(1) амортизированно.
  - rehash/reserve: O(n).
- В худшем случае: O(n).

---

## Итераторы

- Реализовать однонаправленные итераторы, обходящие только Occupied-слоты.
- Инвалидация:
  - Любой rehash, reserve, clear — инвалидирует все итераторы.
  - Изменение значения по существующему ключу — не инвалидирует другие итераторы.
- Требуется поддержка префиксного/постфиксного инкремента, разыменование к прокси-типу с полями `first` (const std::string) и `second` (std::string).
- Должен работать код:
  ```C++
  for (auto it = m.begin(); it != m.end(); ++it) {
      std::cout << it->first << ": " << it->second << "\n";
  }
  ```

---

## Дополнительно (повышенная сложность)

1. Хетерогенный поиск: `find(const char* key)`, `contains(std::string_view)` без аллокации (нельзя использовать std::string_view как член интерфейса — но можно через перегрузки и адаптацию хеша).
2. Метод `insert_or_assign(key, value)` и `erase(iterator)`.
3. Сильная гарантия исключений для всех модифицирующих операций.
4. Пользовательский `Hasher` как шаблонный параметр класса.
5. Режим "shrink_to_fit()" по порогу alpha < 0.15.
6. Стабильная итерация: минимизация "дыр" после серии erase (перепаковка при необходимости).

---

## Технические требования

1. Сборка: CMake (шаблон см. в папке cpp-template).
2. Флаги: включите как минимум `-Wall -Wextra -Wpedantic`, для Linux/macOS — сборки с AddressSanitizer и UBSanitizer (см. ниже).
3. Тесты: GoogleTest. Покройте базовые сценарии, крайние случаи, коллизии, рехеш, удаление/надгробия, итераторы, копирование/перемещение, const-корректность.
4. Время выполнения тестов — разумное (< 5 сек на среднюю машину).

Рекомендуемые тест-кейсы:

- Вставка 10k элементов, проверка целостности после rehash.
- Серии случайных операций (>=100k), сверка с эталонной моделью (например, `std::unordered_map`) по содержимому, но только в тестах.
- Плотная таблица при alpha → max_load_factor, затем erase 50%, затем insert той же серии (проверка Deleted).
- Итерация: полнота и отсутствие дублей, корректная инвалидация.
- Имена, похожие хеши (коллизии), длинные строки.

---

## Требования для автомата

Чтобы получить "автомат", необходимо выполнить все пункты ниже:

1. Функциональные требования:
   - Реализованы все методы из раздела "Обязательный интерфейс" (включая итераторы).
   - Соответствие сложности и инвариантов (открытая адресация, квадратичное пробирование, tombstones).
2. Качество кода:
   - Сборка без предупреждений при `-Wall -Wextra -Wpedantic` (и `/W4` на MSVC). Опционально допускается `-Werror` в CI.
   - Статический анализ: настроен clang-tidy с базовым профилем (`modernize-*`, `performance-*`, `readability-*`), исправлены замечания или задокументированы исключения.
3. Надежность:
   - Все тесты проходят.
   - AddressSanitizer + UndefinedBehaviorSanitizer — без ошибок.
   - Отсутствие утечек памяти (ASan/Valgrind).
4. Покрытие:
   - Code coverage (gcov/llvm-cov) по модулю HashMap: не менее 85% строк и 75% ветвей.
5. Производительность:
   - Микро-бенчмарк 100k вставок и 100k поисков на случайных строках завершаетcя без асимптотических деградаций.
6. Документация:
   - Краткая записка (0.5–1 стр.) с описанием: хеша, схемы пробирования, инвариантов, правил инвалидации итераторов и стратегий rehash.
   - Комментарии в коде к неочевидным участкам (конструирование/разрушение строк в слотах, обработка исключений).
7. История разработки:
   - Не менее 3 содержательных коммитов (инициализация, базовая версия, тесты/фиксы/оптимизация). Понятные сообщения.

В качестве бонуса (может компенсировать один из недочетов): пункт(ы) из раздела "Дополнительно".

---

## Подсказки по реализации

- Структура слота:
  ```C++
  struct Slot {
      enum class State : uint8_t { Empty, Occupied, Deleted } state;
      // Ключ/значение можно хранить как "сырые" буферы + placement new
      // или как обычные поля, но тогда внимательно про исключения.
      std::string key;
      std::string value;
  };
  ```
- Ре-хеш переносит только Occupied-слоты. Сбрасывайте Deleted → Empty.
- Для `const operator[]` верните ссылку на статическую `static const std::string kEmpty;` (гарантируйте длительность жизни).
- Для `reserve(n)`: выберите bucket_count так, чтобы `n <= max_load_factor * bucket_count`.
- После `erase` увеличивайте счетчик tombstones; при переполнении запускайте ре-хеш.

---

## Сдача и проверка

1. Репозиторий с проектом CMake и тестами GoogleTest.
2. Инструкция по запуску тестов и (опционально) скрипт для сборки с Sanitizer-режимом.
3. Результаты покрытия (html-отчет или текстовый вывод).
4. Отчет по производительности (кратко: машина, компилятор/флаги, результаты).

Удачи!
