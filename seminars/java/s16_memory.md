---
marp: true
theme: default
paginate: true
footer: 'Язык программирования Java - Семинар 16'
---

# Java Memory Model и Garbage Collection

## Язык программирования Java - Семинар 16

---

# План занятия

- Java Memory Model: основные понятия
- Структура памяти в JVM
- Стек и куча
- Жизненный цикл объектов
- Garbage Collection: принципы работы
- Типы сборщиков мусора
- Практические аспекты работы с памятью

---

# Java Memory Model

Java Memory Model (JMM) - спецификация, которая определяет:

- Как Java-программа взаимодействует с памятью
- Как потоки взаимодействуют через память
- Правила видимости изменений между потоками
- Гарантии порядка операций

> JMM помогает писать многопоточные программы, которые работают предсказуемо

---

# Структура памяти в JVM

JVM разделяет память на несколько ключевых областей:

- **Heap (Куча)** - для хранения объектов

  - Young Generation (молодое поколение)
    - Eden Space (область создания)
    - Survivor Spaces (области выживших)
  - Old Generation (старое поколение)

- **Stack (Стек)** - отдельный для каждого потока
  - Локальные переменные
  - Вызовы методов
- **Non-Heap области**:
  - Metaspace - метаданные классов
  - Code Cache - JIT-скомпилированный код
  - Native Memory - память для JVM и нативных библиотек

---

# Основные области памяти

- **Heap (куча)** - хранение объектов
- **Stack (стек)** - хранение локальных переменных и вызовов методов
- **Metaspace** - метаданные классов (заменил PermGen)
- **Code Cache** - скомпилированный нативный код (JIT)
- **Native Memory** - память для JVM и нативных библиотек

---

# Стек и куча

**Стек:**

- Локальные переменные и ссылки
- Параметры методов
- LIFO (Last-In-First-Out)
- Для каждого потока свой стек
- Ограниченный размер

**Куча:**

- Все объекты
- Общая для всех потоков
- Динамическое управление памятью
- Здесь работает Garbage Collector

---

# Жизненный цикл объекта в Java

1. **Создание** - выделение памяти, инициализация
2. **Использование** - методы работают с объектом
3. **Недоступность** - когда нет ссылок на объект
4. **Сборка мусора** - освобождение памяти
5. **Финализация** - вызов finalize() (не рекомендуется)

---

# Разбор примера

```java
public void method() {
  Person localPerson = new Person("John"); // Объект в куче, ссылка в стеке
  localPerson.setAge(25);                  // Работа с объектом

  localPerson = null;                      // Ссылка становится null
                       // Объект теперь доступен для GC
}
```

---

# Garbage Collection: основы

**Garbage Collection** - автоматическое управление памятью:

- Находит объекты без ссылок
- Освобождает занимаемую ими память
- Работает в фоновом режиме
- Освобождает программиста от ручного управления памятью

---

# Как GC определяет "мусор"?

Два основных алгоритма:

**Reference Counting:**

- Подсчет ссылок на объект
- Когда счетчик = 0, объект - мусор

**Mark and Sweep (используется в Java):**

- Отметить все достижимые объекты
- Все неотмеченные - мусор, подлежащий сборке

---

# Поколения в куче

**Куча делится на "поколения":**

- **Young Generation** (молодое поколение)
  - **Eden Space** - здесь создаются новые объекты
  - **Survivor Spaces (S0, S1)** - для объектов, переживших сборку мусора
- **Old Generation** (старое поколение)
  - Долгоживущие объекты
  - Объекты, пережившие несколько циклов сборки в Young Generation

_Основная идея: большинство объектов живут недолго,
поэтому сборка в молодом поколении происходит чаще и быстрее_

---

# Виды Garbage Collector в Java

- **Serial GC** - однопоточный, простой
- **Parallel GC** - многопоточный сборщик
- **CMS (Concurrent Mark Sweep)** - минимизация пауз
- **G1 (Garbage First)** - для больших куч, разделение на регионы
- **ZGC** - масштабируемый сборщик с малыми паузами
- **Shenandoah** - сборщик с малыми паузами от Red Hat

---

# Как работает сборка мусора (упрощенно)

1. **Stop-the-world** - приостановка всех потоков приложения
2. **Mark** - пометка достижимых объектов
3. **Sweep/Compact** - удаление мусора и дефрагментация
4. **Возобновление работы** приложения

---

# Ссылки в Java

- **Strong References** - обычные ссылки
- **Soft References** - собираются при нехватке памяти
- **Weak References** - собираются при следующем GC
- **Phantom References** - для особого контроля освобождения ресурсов

```java
SoftReference<Resource> softRef = new SoftReference<>(resource);
WeakReference<Resource> weakRef = new WeakReference<>(resource);
```

---

# Признаки проблем с памятью

- OutOfMemoryError
- Частые длительные GC-паузы
- Высокое потребление CPU сборщиком мусора
- Постоянно растущее потребление памяти (memory leak)

---

# Практические советы

- Используйте инструменты: VisualVM, JConsole, JProfiler
- Правильно настраивайте размеры памяти (-Xms, -Xmx)
- Выбирайте подходящий сборщик мусора
- Освобождайте внешние ресурсы (try-with-resources)
- Избегайте создания лишних объектов
- Будьте осторожны со статическими коллекциями

---

# Вопросы для самопроверки

1. Как устроена память в JVM?
2. Что означает "достижимость объекта"?
3. В чем разница между Stack и Heap?
4. Какие бывают типы ссылок в Java?
5. Как работает алгоритм "Mark and Sweep"?

---

# Полезные ресурсы

- [Java Memory Management](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)
- [Understanding Java Garbage Collection](https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works/)
- [Memory Management in Java](https://www.baeldung.com/java-memory-management-interview-questions)

---

# Спасибо за внимание!

Вопросы?
