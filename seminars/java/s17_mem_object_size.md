---
marp: true
theme: default
paginate: true
---

# Размер объектов в Java

## Важно для понимания управления памятью и оптимизации производительности

---

### Почему это важно?

- Эффективное управление памятью JVM
- Оптимизация использования оперативной памяти
- Устранение утечек памяти в приложениях
- Понимание внутренней структуры JVM

---

## Структура объекта в Java Heap

```java
class Example {
    int field1;
    String field2;
}
```

| Компонент           | Размер (байты)  |
| ------------------- | --------------- |
| Объектный заголовок | 12 (64-bit JVM) |
| Поля                | ?               |
| Alignment padding   | до 8 байт       |

---

## Расчёт размера объекта

### Формула:

```
Total size = object header + fields size + alignment padding
```

**Пример:**

```java
class Data {
    byte b;     // 1 byte
    int i;      // 4 bytes
    long l;     // 8 bytes (with alignment)
}
// Total ≈ 12 (header) + 1+3(padding)+4+4(padding)+8 = 32 bytes
```

---

## Инструменты для измерения

```java
// Использование Java Object Layout
import org.openjdk.jol.info.*;

public class Main {
    public static void main(String[] args) {
        System.out.println(ClassLayout.parseClass(String.class).toPrintable());
    }
}
```

---

## Практические примеры

| Объект               | Приблизительный размер |
| -------------------- | ---------------------- |
| `new Object()`       | 16B (header + padding) |
| `new String("test")` | ~40B                   |
| `[1,2,3] int[]`      | 20+4\*N bytes          |

---

## Влияние JVM параметров

- **CompressedOops** (по умолчанию в 64-bit JVM):
  - Ссылки сжимаются до 4 байт
- Без сжатия:
  - Ссылки занимают 8 байт

---

## Рекомендации по оптимизации

1. **Избегайте создания избыточных объектов**
   - Используйте примитивные типы вместо обёрток (`int` vs `Integer`)
   - Переписывайте циклы с минимизацией временных объектов
2. **Группировка полей по типу**
   ```java
   // Хорошо: все поля int в кластере
   class Point {
       private int x;
       private int y;
   }
   ```
3. **Избегайте дублирования ссылок**
4. **Учитывайте выравнивание памяти** (8-байтные блоки)

---

## Пример: Сравнение структур

```java
class A {
    byte b;   // 1B + 7B padding
    int i;    // 4B
}           // Total: 24B
```

```java
class B {
    int i;    // 4B
    byte b;   // 1B
}           // Total: 16B (лучшая компактность)
```

---

## Типичные заблуждения

| Миф                           | Реальность                        |
| ----------------------------- | --------------------------------- |
| "Все ссылки занимают 4 байта" | Зависит от `CompressedOops`       |
| "Пустой объект весит 0 байт"  | Минимум 16B (заголовок + padding) |
| "Массивы не требуют padding"  | Требуют выравнивания              |

---

## Практическая задача

**Рассчитайте размер класса:**

```java
class User {
    String name;   // ссылка 4/8B
    int age;       // 4B
    byte active;   // 1B
}
```

**Варианты ответов (для 64-bit JVM с CompressedOops):**

- Сценарий A: 24B
- Сценарий B: 32B
  (Учитывайте выравнивание!)

---

## Влияние модификаторов

| Модификатор   | Эффект на размер       |
| ------------- | ---------------------- |
| `transient`   | Не влияет (в heap)     |
| `volatile`    | Увеличивает размер +4B |
| `final field` | Может сократить память |

---

## Когда оптимизация не нужна

- Для малочастотных объектов
- В задачах, где доминирует CPU нагрузка
- При работе с примитивными коллекциями

**Золотое правило:**
Измеряйте производительность до и после изменений!

---

## Полезные ресурсы

1. [Java Object Layout (JOL)](https://openjdk.org/projects/code-tools/jol/)
2. "Effective Java" - Джошуа Блох, главы про память
3. JVM Internals Manual

---

### Вопросы?

#### Практическое задание:

1. Измерьте размер `new ArrayList<String>(5)`
2. Сравните с массивом `String[5]`
   (Используйте JOL и визуализацию)
