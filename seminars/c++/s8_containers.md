---
marp: true
theme: default
paginate: true
---

# Стандартные контейнеры STL C++

## Семинар 8

---

## Что такое STL?

**Standard Template Library (STL)** — стандартная библиотека шаблонов C++

Основные компоненты:

- **Контейнеры** - структуры данных для хранения объектов
- **Итераторы** - объекты для обхода контейнеров
- **Алгоритмы** - функции для работы с данными

```cpp
#include <vector>
#include <algorithm>
#include <iostream>
```

---

## Классификация контейнеров

### Последовательные контейнеры

- `vector`, `deque`, `list`, `array`

### Ассоциативные контейнеры

- `set`, `multiset`, `map`, `multimap`

### Неупорядоченные ассоциативные контейнеры

- `unordered_set`, `unordered_map`

### Адаптеры контейнеров

- `stack`, `queue`, `priority_queue`

---

## vector - динамический массив

```cpp
#include <vector>

std::vector<int> v1;                    // пустой вектор
std::vector<int> v2(5);                 // 5 элементов (0)
std::vector<int> v3(5, 10);            // 5 элементов (10)
std::vector<int> v4 = {1, 2, 3, 4, 5}; // из списка

// Основные операции
v1.push_back(42);        // добавить в конец
v1.pop_back();          // удалить последний
v1.size();              // размер
v1.empty();             // проверка на пустоту
v1[0];                  // доступ по индексу
v1.at(0);              // безопасный доступ
```

---

## vector - пример использования

```cpp
#include <vector>
#include <iostream>

int main() {
  std::vector<int> numbers = {1, 2, 3, 4, 5};

  // Добавление элементов
  numbers.push_back(6);

  // Обход контейнера
  for (int num : numbers) {
    std::cout << num << " ";
  }

  // Изменение размера
  numbers.resize(10, 0);  // увеличить до 10, заполнить нулями

  return 0;
}
```

---

## deque - двусторонняя очередь

```cpp
#include <deque>

std::deque<int> d;

// Операции в начале и конце
d.push_back(1);     // добавить в конец
d.push_front(0);    // добавить в начало
d.pop_back();       // удалить с конца
d.pop_front();      // удалить с начала

// Доступ как у vector
d[0];               // доступ по индексу
d.at(1);           // безопасный доступ
```

**Особенности:**

- Эффективные вставки/удаления в начале и конце
- Произвольный доступ к элементам

---

## list - двусвязный список

```cpp
#include <list>

std::list<int> l = {1, 2, 3, 4, 5};

// Операции
l.push_back(6);     // добавить в конец
l.push_front(0);    // добавить в начало
l.pop_back();       // удалить с конца
l.pop_front();      // удалить с начала

// Вставка/удаление в произвольном месте
auto it = l.begin();
++it;  // второй элемент
l.insert(it, 42);   // вставить перед вторым элементом
l.erase(it);        // удалить элемент
```

---

## set - множество уникальных элементов

```cpp
#include <set>

std::set<int> s = {3, 1, 4, 1, 5, 9}; // автоматически: {1, 3, 4, 5, 9}

// Операции
s.insert(2);        // вставка
s.erase(3);         // удаление по значению
s.count(4);         // проверка наличия (0 или 1)
s.find(5);          // поиск (возвращает итератор)

// Обход (элементы отсортированы)
for (int x : s) {
  std::cout << x << " ";
}
```

**Особенности:**

- Автоматическая сортировка
- Уникальные элементы
- Логарифмическое время операций

---

## map - ассоциативный массив

```cpp
#include <map>

std::map<std::string, int> ages;

// Добавление элементов
ages["Alice"] = 25;
ages["Bob"] = 30;
ages.insert({"Charlie", 35});

// Доступ
std::cout << ages["Alice"];    // 25
auto it = ages.find("Bob");
if (it != ages.end()) {
  std::cout << it->second;   // 30
}

// Обход
for (const auto& pair : ages) {
  std::cout << pair.first << ": " << pair.second << std::endl;
}
```

---

## unordered_map - хеш-таблица

```cpp
#include <unordered_map>

std::unordered_map<std::string, int> scores;

scores["player1"] = 100;
scores["player2"] = 200;

// Операции аналогичны map
// Но среднее время доступа O(1) вместо O(log n)
```

**Отличия от map:**

- Константное среднее время операций
- Элементы не отсортированы
- Требует хеш-функцию для ключа

---

## Адаптеры контейнеров

### stack - стек (LIFO)

```cpp
#include <stack>
std::stack<int> st;
st.push(1);     // добавить
st.push(2);
int top = st.top();  // верхний элемент (2)
st.pop();       // удалить верхний
```

### queue - очередь (FIFO)

```cpp
#include <queue>
std::queue<int> q;
q.push(1);      // добавить
q.push(2);
int front = q.front();   // первый элемент (1)
q.pop();        // удалить первый
```

---

## Итераторы

```cpp
#include <vector>
#include <algorithm>

std::vector<int> v = {1, 2, 3, 4, 5};

// Типы итераторов
auto begin_it = v.begin();      // начало
auto end_it = v.end();          // конец (за последним)
auto rbegin_it = v.rbegin();    // обратный итератор

// Использование
for (auto it = v.begin(); it != v.end(); ++it) {
  std::cout << *it << " ";
}

// Range-based for
for (int x : v) {
  std::cout << x << " ";
}
```

---

## Алгоритмы STL

```cpp
#include <algorithm>
#include <vector>

std::vector<int> v = {3, 1, 4, 1, 5, 9};

// Сортировка
std::sort(v.begin(), v.end());

// Поиск
auto it = std::find(v.begin(), v.end(), 4);
if (it != v.end()) {
  std::cout << "Найден: " << *it;
}

// Подсчет
int count = std::count(v.begin(), v.end(), 1);  // сколько единиц

// Преобразование
std::transform(v.begin(), v.end(), v.begin(),
         [](int x) { return x * 2; });  // умножить на 2
```

---

## Выбор контейнера

| Операция          | vector                 | deque             | list              | set      | map      |
| ----------------- | ---------------------- | ----------------- | ----------------- | -------- | -------- |
| Доступ по индексу | O(1)                   | O(1)              | O(n)              | -        | -        |
| Вставка в конец   | O(1) (амортизированно) | O(1)              | O(1)              | O(log n) | O(log n) |
| Вставка в начало  | O(n)                   | O(1)              | O(1)              | O(log n) | O(log n) |
| Поиск             | O(n)                   | O(n)              | O(n)              | O(log n) | O(log n) |
| Память            | компактная             | фрагментированная | фрагментированная | overhead | overhead |

---

## Практические рекомендации

### Используйте vector когда:

- Нужен произвольный доступ к элементам
- Часто добавляете элементы в конец
- Важна компактность в памяти

### Используйте deque когда:

- Нужны вставки/удаления в начале и конце
- Нужен произвольный доступ

### Используйте list когда:

- Часто вставляете/удаляете в середине
- Размер сильно меняется

### Используйте set/map когда:

- Нужна сортировка или уникальность
- Часто выполняете поиск

---

## Заключение

**STL-контейнеры** предоставляют:

- Готовые, оптимизированные структуры данных
- Единообразный интерфейс
- Совместимость с алгоритмами STL
- Безопасность типов

**Помните:**

- Выбирайте контейнер под задачу
- Изучайте сложность операций
- Используйте range-based for loops
- Предпочитайте алгоритмы STL самописным циклам
- Используйте range-based for loops
- Предпочитайте алгоритмы STL самописным циклам
